#set($hash = '#')${hash} Frontend Build: React App

This project was bootstrapped with [`create-react-app`](https://github.com/facebook/create-react-app).

This application is built to consume the AEM model of a site. It will automatically generate the layout using the helper components from the [`@adobe/aem-react-editable-components`](https://www.npmjs.com/package/@adobe/aem-react-editable-components) package.

${hash}${hash} Scripts

In the project directory, you can run the following commands:

${hash}${hash}${hash} `npm start`

Runs the app in development mode by proxying the JSON model from a local AEM instance running at http://localhost:4502. This assumes that the entire project has been deployed to AEM at least once (`mvn clean install -PautoInstallPackage` **in the project root**).

After running `npm start` **in the `ui.frontend` directory**, your app will be automatically opened in your browser (at path http://localhost:3000/content/${appId}/${country}/${language}/home.html). If you make edits, the page will reload.

If you are getting errors related to CORS, you might want to configure AEM as follows:

1. Navigate to the Configuration Manager (http://localhost:4502/system/console/configMgr)
2. Open the configuration for "Adobe Granite Cross-Origin Resource Sharing Policy"
3. Create a new configuration with the following additional values:
   - Allowed Origins: http://localhost:3000
   - Supported Headers: Authorization
   - Allowed Methods: OPTIONS

${hash}${hash}${hash} `npm test`

Launches the test runner in the interactive watch mode. See the section about [running tests](https://facebook.github.io/create-react-app/docs/running-tests) for more information.

${hash}${hash}${hash} `npm run build`

Builds the app for production to the `build` folder. It bundles React in production mode and optimizes the build for the best performance. See the section about [deployment](https://facebook.github.io/create-react-app/docs/deployment) for more information.

Furthermore, an AEM ClientLib is generated from the app using the [`aem-clientlib-generator`](https://github.com/wcm-io-frontend/aem-clientlib-generator) package.

${hash}${hash} Browser Support

By default, this project uses [Browserslist](https://github.com/browserslist/browserslist)'s `defaults` option to identify target browsers. Additionally, it includes polyfills for modern language features to support older browsers (e.g. Internet Explorer 11). If supporting such browsers isn't a requirement, the polyfill dependencies and imports can be removed.

${hash}${hash} Custom Model Client

For scenarios where the react application doesn't have access to the model json payload a request to AEM has to be made to fetch it. This may require a custom model client that can provide additional capabilities over the default one provided via the [`aem-spa-page-model-manager`](https://github.com/adobe/aem-spa-page-model-manager/blob/master/src/ModelClient.ts) such as authentication.

${hash}${hash} Code Splitting

The React app is configured to make use of [code splitting](https://webpack.js.org/guides/code-splitting) by default. When building the app for production, the code will be output in several chunks:

```sh
$ ls build/static/js
2.5b77f553.chunk.js
2.5b77f553.chunk.js.map
main.cff1a559.chunk.js
main.cff1a559.chunk.js.map
runtime~main.a8a9905a.js
runtime~main.a8a9905a.js.map
```

Loading chunks only when they are required can improve the app performance significantly.

To get this feature to work with AEM, the app needs to be able to identify which JS and CSS files need to be requested from the HTML generated by AEM. This can be achieved using the `"entrypoints"` key in the `asset-manifest.json` file: The file is parsed in `clientlib.config.js` and only the entrypoint files are bundled into the ClientLib. The remaining files are placed in the ClientLib's `resources` directory and will be requested dynamically and therefore only loaded when they are actually needed.


#if ( $enableSSR == "y" )

${hash} Frontend Serverless Build (Adobe IO Runtime)

${hash}${hash} Features

* AdobeIO Runtime (Serverless) rendering of the SPA editor 
* Local + Remote development
* Uses AIO CLI

${hash}${hash} Installation

1. Install [NodeJS](https://nodejs.org/en/download/) (v10+), globally. This will also install `npm`.
2. Navigate to `ui.frontend` in your project and run `npm install`. (You must have run the archetype with `-DfrontendModule=react` for this to work)
3. If running locally the following images must be installed:
   * docker pull openwhisk/action-nodejs-v10:latest
   * docker pull adobeapiplatform/adobe-action-nodejs-v10:3.0.21

${hash}${hash} Usage

The following npm scripts are available for deployment under `ui.frontend.ssr.ioruntime`:

* `build-with-ssr` - Build serverless code for IO Runtime(debuggable with sourcemaps)
* `build-with-express` - Build express code (debuggable with sourcemaps)
* `start-ssr-ioruntime` - Deploys the serverless code to a local docker container with AIO CLI. Requires docker running. Enables you to debug with visual studio code.
* `start-ssr-express` - Runs the express code (debuggable with sourcemaps)
* `deploy-ssr-ioruntime` - Deploys the serverless code to your IO runtime namespace. Requires the environment variables AIO_RUNTIME_NAMESPACE and AIO_RUNTIME_AUTH to be set.

${hash}${hash}${hash}${hash} Notes

To summarize, the way this works:

${hash}${hash}${hash}${hash}${hash} 1: the servlet (in the body.html) will call the serverless endpoint on a page request, sending over the page data using sling model exporters as JSON
${hash}${hash}${hash}${hash}${hash} 2: the serverless code consumes the JSON and returns pre-rendered HTML over
${hash}${hash}${hash}${hash}${hash} 3: the servlet puts this inside the HTML
${hash}${hash}${hash}${hash}${hash} 4: the react app detects the pre-rendered HTML and hydrates the app instead of rendering it:

${hash}${hash}${hash}${hash}${hash} The Runtime action depends on the code produced by ui.frontend.react. This dependency is automatically copied over as part of the maven build via a post-build webhook. When developing/testing, you will need to trigger this process before deploying the action for the changes to take effect.

${hash}${hash}${hash}${hash} Details:

The server-side rendering gets kicked off by the following SLY statement in your body.html of the page:
```html
<!-- this starts the SSR rendering chain !-->
<div id="spa-root" data-sly-resource="${symbol_dollar}{resource @ resourceType='cq/remote/content/renderer/request/handler'}"></div>

```

This will trigger the out of the box remote renderer.
The renderer is configured by the following configuration:

com.adobe.cq.remote.content.renderer.impl.factory.ConfigurationFactoryImpl~mysite.cfg

```json
{
    "getContentPathPattern": "/content/mysite/(.*)|/conf/mysite/(.*)/settings/wcm/templates/(.*)",
    "getRemoteHTMLRendererUrl" : "http://localhost:3233/api/v1/web/guest/react-server-1.1.2/ssr",
    "getRequestTimeout": 10000,
    "getAdditionalRequestHeaders": [
    
    ]
}
```

In here you put the correct endpoint. By default for demonstration purposes the endpoint is configured to your localhost.
So to get a demo quickly just run the `npm run run-local` script after a full installation.
Refresh the page and you should see the pre-rendered HTML in the page source.


For production purposes the URL should point to an actual IO runtime instance.
Under "getAdditionalRequestHeaders" of this configuration you can put an authentication header that is needed for IO Runtime, or any other static headers that are desired.

Production:

```json
{
    "getContentPathPattern": "/content/mysite/(.*)|/conf/mysite/(.*)/settings/wcm/templates/(.*)",
    "getRemoteHTMLRendererUrl" : "https://adobeioruntime.net/api/v1/web/<your-namespace-here>/react-server-1.1.2/ssr",
    "getRequestTimeout": 10000,
    "getAdditionalRequestHeaders": [
        "Auth: Basic <your key here>"
    ]
}
```

Finally, the initialization script of the app is different:

```js
const initialStateScriptTag = document.getElementById('__INITIAL_STATE__');
if(!!initialStateScriptTag){

    try{
        const initialState = JSON.parse(initialStateScriptTag.innerHTML);
        initialStateScriptTag.remove();
        hydrateApp(initialState);
        
        console.info('hydrated react DOM');
    }catch(err) {
        console.error('failed to parse initial state json! re-rendering output.', err);
        renderApp();
    }
}
```
This will just attach the event handlers to the already existing DOM instead of re-rendering it, for even more performance.

And that is it! You got your server-side rendering stack running on serverless!
For more customization / bells and whistles there are other examples that require you to eject your react-app or to write the servlet yourself:

[React core components - Examples - Typescript, code-splitting, lazy-loading, experience fragments example](https://github.com/adobe/aem-react-core-wcm-components/tree/master/examples/react-spacomponents-example-project)

But this is a great base to get started with minimal code and complexity.

#end
